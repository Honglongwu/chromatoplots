setMethod("explore", c("xcmsSet", protocolClass("rtcor")),
          function(object, protocol, raw=NULL,
                   xscale=NULL,geom=c("line","heatmap"),sample=NULL,log=FALSE,gg = ggobi()) {
            if(is.null(raw)){
              if(is.null(getData("findComps"))){
                message('Raw data after finding components and before retention time correction is missing,\n
data neet to be regenerated again(maybe time-consuming),\n
are you sure you want to reprocess these data?')
                res <- menu(c("Yes","No"))
                if(res==1){
                  rawpipeline <- pipeline(pipeline(processRawsProto(object)),
                                          outtype = "xcmsRaw")
                  rawfiles <- object@filepaths
                  raw <- perform(rawpipeline,rawfiles[sample])
                }else{
                  return()
                }}else{
                  raw <- getData("findComps")
                }
            }
            ## raw <- perform(processProto(object@pipeline,'findComps'),
            ##                object@filepaths)
            ## s <- object@comps[,"sample"] == sample
            ## retcor_d <- data.frame(raw = raw@comps[s,"rt"],
            ##                        cor = object@comps[s,"rt"])
            ## p_retcor_fit <- qplot(raw, cor-raw, data = retcor_d)+
            ##   scale_x_continuous(limits=c(360,1000)) + geom_smooth()
            ## p_tic_cor <- plot_tic_rtcor(raws, object@rt$corrected,sample)
            ## p_tic_cor$title <- NULL
            gg_comp_chain <- gg_all_comps_disp(object@comps,gg)
            ## stack_plots("Retention Time Correction",
            ##             list(p_tic_cor, p_retcor_fit, gg_comp_chain))
            geom <- match.arg(geom)
            if(length(geom)>1) geom <- "line"
            p_retcor_fit <- cplotRtFit(object,raw,xscale,sample)
            p_rt <- cplotRT(object,xscale=xscale,sample=sample,geom=geom,log=log)
            stack_plots("Retention Time Correction",
                        list(p_rt,p_retcor_fit,gg_comp_chain))
          })

cplotRT <- function(object,xscale=NULL,geom=c("line","heatmap"),sample=NULL,log=F){
  path <- object@filepaths
  tic <- list()
  sample.names <- rownames(object@phenoData)
  if(is.null(sample)) {
    sample=unique(object@comps[,'sample'])
  }
  sample=sample.names[sample]
##  raw <- getData("loadSample")
##  if(is.null(raw)){
  getOption("BioC")$commandr$data_mode
    for(i in 1:length(path)){
      raw <- loadSample(path[i])
      tic[[i]] <- raw@tic
    }
  restoreDataMode()
##  }
  rt <- object@rt
  if(is.null(xscale)){
    xscale <- range(unlist(rt))
  }
  df2 <- data.frame()
  for(i in 1:length(rt)){
    x <- unlist(rt[[i]])
    df <- data.frame(rt=x,tic=unlist(tic),sample=rep(sample.names,each=length(rt[[1]][[1]])),
                     type=names(rt)[i],level=rep(1:length(rt[[1]]),each=length(rt[[1]][[1]])))
    df2 <- rbind(df2,df)
  }
  df2 <- df2[df2$sample%in%sample,]
  df2$sample <- factor(df2$sample)
  if(geom=="line"){
    if(log){
      p<- qplot(rt,log(tic+1),group=sample,colour=sample,data=df2,geom="path",facets=type~.)+
        scale_x_continuous(limits=xscale)+
          scale_y_continuous(limits=range(df2[which(df2$rt<xscale[2]&df2$rt>xscale[1]),'tic']))+
            opts(legend.position="none")
    }else{
      p<- qplot(rt,tic,group=sample,colour=sample,data=df2,geom="path",facets=type~.)+
        scale_x_continuous(limits=xscale)+
          scale_y_continuous(limits=range(df2[which(df2$rt<xscale[2]&df2$rt>xscale[1]),'tic']))+
            opts(legend.position="none")
    }}
  if(geom=="heatmap"){
    if(log==FALSE){
      p <- qplot(x=rt,y=level,xend=rt,yend=level-0.9,data=df2,colour=tic,geom="segment",facets=type~.,ylab="sample")+
        scale_colour_gradient(low="yellow",high="red")+
          scale_x_continuous(limits=xscale)+
            scale_y_continuous(breaks=1:length(rt[[1]]))+
              opts(legend.position="none")
    }else{
      p <- qplot(x=rt,y=level,xend=rt,yend=level-0.9,data=df2,colour=log(tic+1),geom="segment",facets=type~.,ylab="sample")+
        scale_colour_gradient(low="yellow",high="red")+
          scale_x_continuous(limits=xscale)+
            scale_y_continuous(breaks=1:length(rt[[1]]))+
              opts(legend.position="none")
    }
  }
  p
}


cplotRtFit <- function(object,raw,xscale=NULL,sample=NULL){
  sample.names <- rownames(object@phenoData)
  if(is.null(sample)) sample=unique(object@comps[,'sample'])
  s <- object@comps[,'sample']%in%sample
  retcor_d <- data.frame(raw=raw@comps[s,'rt'],
                         cor=object@comps[s,'rt'],
                         sample=sample.names[object@comps[s,'sample']])
  retcor_d$sample <- factor(retcor_d$sample)
  if(is.null(xscale)) xscale=range(c(retcor_d$raw,retcor_d$cor))
  p_retcor_fit <- qplot(raw,cor-raw,data=retcor_d,color=sample,group=sample,size=1)+
    scale_x_continuous(limits=xscale)+geom_smooth(se=FALSE)
  p_retcor_fit
}


plot_tic_rtcor <- function(raws, time, sample,label = "corrected") {
  init <- data.frame(time = time[[sample]], tic = raws[[sample]]@tic)
  p <- ggplot(init, aes(x = time, y = tic)) + geom_line() +
    scale_x_continuous(limits=c(360,500)) +
      scale_y_continuous(limits=c(0,5e6))
  for (i in tail(seq_along(raws), -1))
    {
      p <- p + geom_line(aes(x = time[[i]], y = raws[[i]]@tic))
    }
  p$title <- paste("TIC Chromatograms (", label, ")", sep="")
  p
}

